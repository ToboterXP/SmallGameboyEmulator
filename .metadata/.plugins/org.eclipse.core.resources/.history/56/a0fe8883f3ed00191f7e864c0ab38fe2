/*
 * i20_3f.h
 *
 *  Created on: 13.10.2019
 *      Author: Tobias
 */

#ifndef I20_3F_H_
#define I20_3F_H_

#include <cstdint>
#include "Processor.h"

namespace proc {

int execute20_3f(uint8_t opcode, Processor * proc) {
	switch (opcode) {
	case 0x20: //jr nz,r8
		int8_t jump = proc->getInstruction8();
		if (!(proc->getFlag(ZERO_FLAG))) {
			proc->pc += jump;
			return 3;
		}
		return 2;
	case 0x21: // ld hl,d16
		proc->setHL(proc->getInstruction16());
		return 3;
	case 0x22: //ld (hl+),a
		proc->memory->writeMemory(proc->getHL(),proc->a);
		proc->setHL(proc->getHL()+1);
		return 2;
	case 0x23: //inc hl
		proc->setHL(proc->getHL()+1);
		return 2;
	case 0x24: //inc h
		uint8_t prev = proc->h;
		proc->h++;
		proc->setFlag(ZERO_FLAG,proc->h==0);
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf+1)&0x10==0x10);
		return 1;
	case 0x25: //dec h
		uint8_t prev = proc->h;
		proc->h--;
		proc->setFlag(ZERO_FLAG,proc->h==0);
		proc->setFlag(SUB_FLAG,1);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf-1)&0x10==0x10);
		return 1;
	case 0x26: //ld h,d8
		proc->h = proc->getInstruction8();
		return 2;
	case 0x27: //daa
		if (proc->getFlag(SUB_FLAG)) {
			uint8_t firstDigit = proc->a&0xf;
			uint8_t secondDigit = ((proc->a)>>8) & 0xf;
			if (firstDigit>9 || proc->getFlag(HALF_CARRY_FLAG)) firstDigit += 6;
			if (secondDigit>9 || proc->getFlag(CARRY_FLAG)) secondDigit += 6;
			proc->a = firstDigit;
			proc->a &= 0xf;
			proc->a |= secondDigit<<4;
		} else {
			uint8_t firstDigit = proc->a&0xf;
			uint8_t secondDigit = ((proc->a)>>8) & 0xf;
			if (firstDigit>9 || proc->getFlag(HALF_CARRY_FLAG)) firstDigit -= 6;
			if (secondDigit>9 || proc->getFlag(CARRY_FLAG)) secondDigit -= 6;
			proc->a = firstDigit;
			proc->a &= 0xf;
			proc->a |= secondDigit<<4;
		}
		proc->setFlag(CARRY_FLAG,proc->a>0x99);
		proc->setFlag(ZERO_FLAG,proc->a==0);
		proc->setFlag(SUB_FLAG,0);
		return 1;
	case 0x28: //jr z,r8
		int8_t jump = proc->getInstruction8();
		if (proc->getFlag(ZERO_FLAG)) {
			proc->pc += jump;
			return 3;
		}
		return 2;
	case 0x29: //add hl,hl
		uint16_t prev1 = proc->getHL();
		proc->setHL(proc->getHL() + proc->getHL());
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf+proc->getHL()&0xf)&0x10==0x10);
		proc->setFlag(CARRY_FLAG,prev1 > proc->getHL());
		return 2;
	case 0x2a: //ld a,(hl+)
		proc->a = proc->memory->readMemory(proc->getHL());
		proc->setHL(proc->getHL()+1);
		return 2;
	case 0x2b: //dec hl
		proc->setHL(proc->getHL()-1);
		return 2;
	case 0x2c: //inc l
		uint8_t prev = proc->l;
		proc->l++;
		proc->setFlag(ZERO_FLAG,proc->l==0);
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf+1)&0x10==0x10);
		return 1;
	case 0x2d: //dec l
		uint8_t prev = proc->l;
		proc->l--;
		proc->setFlag(ZERO_FLAG,proc->l==0);
		proc->setFlag(SUB_FLAG,1);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf-1)&0x10==0x10);
		return 1;
	case 0x2e: //ld l,d8
		proc->l = proc->getInstruction8();
		return 2;
	case 0x2f: //cpl
		proc->a = ~proc->a;
		proc->setFlag(SUB_FLAG,1);
		proc->setFlag(HALF_CARRY_FLAG,1);
		return 1;
	case 0x30: //jr nc,r8
		int8_t jump = proc->getInstruction8();
		if (!(proc->getFlag(CARRY_FLAG))) {
			proc->pc += jump;
			return 3;
		}
		return 2;
	case 0x31: //ld sp,d16
		proc->sp = proc->getInstruction16();
		return 3;
	case 0x32: //ld (hl-),a
		proc->memory->writeMemory(proc->getHL(),proc->a);
		proc->setHL(proc->getHL()-1);
		return 2;
	case 0x33: //inc sp
		proc->sp++;
		return 2;
	case 0x34: //inc (hl)
		uint8_t prev = proc->memory->readMemory(proc->getHL());
		proc->memory->writeMemory(proc->getHL(),prev+1);
		proc->setFlag(ZERO_FLAG,proc->memory->readMemory(proc->getHL())==0);
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf+1)&0x10==0x10);
		return 3;

	case 0x15: //dec d
		uint8_t prev = proc->d;
		proc->d--;
		proc->setFlag(ZERO_FLAG,proc->d==0);
		proc->setFlag(SUB_FLAG,1);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf-1)&0x10==0x10);
		return 1;
	case 0x16: //ld d,d8
		proc->d = proc->getInstruction8();
		return 2;
	case 0x17: //rla
		uint8_t bit7 = (proc->a)>>7;
		uint8_t carry = proc->getFlag(CARRY_FLAG);
		proc->setFlag(CARRY_FLAG, bit7);
		proc->a <<= 1;
		proc->a &= ~1;
		proc->a |= carry;
		proc->setFlag(ZERO_FLAG,0);
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,0);
		return 1;
	case 0x18: //jr r8
		proc->pc += (int8_t)(proc->getInstruction8());
		return 3;
	case 0x19: //add hl,DE
		uint16_t prev1 = proc->getHL();
		proc->setHL(proc->getHL() + proc->getDE());
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf+proc->getDE()&0xf)&0x10==0x10);
		proc->setFlag(CARRY_FLAG,prev1 > proc->getHL());
		return 2;
	case 0x1a: //ld a,(de)
		proc->a = proc->memory->readMemory(proc->getDE());
		return 2;
	case 0x1b: //dec de
		proc->setDE(proc->getDE()-1);
		return 2;
	case 0x1c: //inc e
		uint8_t prev = proc->e;
		proc->e++;
		proc->setFlag(ZERO_FLAG,proc->e==0);
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf+1)&0x10==0x10);
		return 1;
	case 0x1d: //dec e
		uint8_t prev = proc->e;
		proc->e++;
		proc->setFlag(ZERO_FLAG,proc->e==0);
		proc->setFlag(SUB_FLAG,1);
		proc->setFlag(HALF_CARRY_FLAG,(prev&0xf-1)&0x10==0x10);
		return 1;
	case 0x1e: //ld e,d8
		proc->e = proc->getInstruction8();
		return 2;
	case 0x1f: //rra
		uint8_t bit0 = proc->a & 1;
		uint8_t carry = proc->getFlag(CARRY_FLAG);
		proc->setFlag(CARRY_FLAG, bit0);
		proc->a >>= 1;
		proc->a &= ~(1<<7);
		proc->a |= carry<<7;
		proc->setFlag(ZERO_FLAG,0);
		proc->setFlag(SUB_FLAG,0);
		proc->setFlag(HALF_CARRY_FLAG,0);
		return 1;
	}
}

}
#endif /* I20_3F_H_ */
