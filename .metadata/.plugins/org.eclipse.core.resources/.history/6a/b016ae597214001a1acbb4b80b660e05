/*
 * APU.cpp
 *
 *  Created on: 01.12.2019
 *      Author: Tobias
 */

#include <audio/APU.h>

namespace audio {

APU::APU(MemoryManager * memory) {
	this->memory = memory;
	audio = new AudioInterface();
}

APU::~APU() {
	delete audio;
}

void APU::clock() {
	if (!(memory->readMemory(0xff26)&(1<<7))) {
		c1_enabled = false;
		c2_enabled = false;
		audio->silenceChannel(CHANNEL_SQUARE_1);
		audio->silenceChannel(CHANNEL_SQUARE_2);
		return;
	}

	for (int i=0;i<4;i++) {
		int soundEnable = memory->readMemory(0xff25)>>i;
		bool on = (soundEnable&1)&((soundEnable>>4)&1);
		if (!on) audio->silenceChannel(i);
	}
	//channel 1
	if (memory->lastAccess == 0xff10) {
		c1_sweepShift = memory->readMemory(0xff10)&7;
		c1_sweepInc = (memory->readMemory(0xff10)&(1<<3)) ? -1 : 1;
		c1_sweepTime = (memory->readMemory(0xff10)&(7<<4))>>4;
	}

	if (memory->lastAccess==0xff12) {
		c1_volume = (memory->readMemory(0xff12)&(15<<4))>>4;
		if (c1_volume==1) c1_volume = 0;
		c1_envelopeInc = (memory->readMemory(0xff12)&3) ? 1 : -1;
		c1_envelopeSweep = memory->readMemory(0xff12)&7;
		audio->setChannelVolume(CHANNEL_SQUARE_1,c1_volume);
	}

	if (memory->lastAccess == 0xff11 && c1_enabled) {
		c1_duty = DUTY_CYCLES[(memory->readMemory(0xff11)&(3<<6))>>6];
		audio->playSquareWave(131072/(2048-c1_freq),CHANNEL_SQUARE_1,c1_duty);
	}

	if (((memory->lastAccess == 0xff14) && (memory->readMemory(0xff14)&(1<<7)))) {
		c1_enabled = true;
		c1_remaining = 64-(memory->readMemory(0xff11)&(~(3<<6)));
		if (!(memory->readMemory(0xff14)&(1<<6))) c1_remaining = -1;
		c1_freq = 0;
		c1_freq |= memory->readMemory(0xff13);
		c1_freq |= (memory->readMemory(0xff14)&7)<<8;

		c1_duty = DUTY_CYCLES[(memory->readMemory(0xff11)&(3<<6))>>6];
		audio->playSquareWave(131072/(2048-c1_freq),CHANNEL_SQUARE_1,c1_duty);
		SDL_Log("c1 audio %i %i %i\n",c1_freq,c1_duty,c1_remaining);

		if (memory->lastAccess != 0xff11)
			c1_sweepTimer = c1_sweepTime*2;

		SDL_Log("c1 sweep %i %i %i %i\n",c1_sweepShift,c1_sweepInc,c1_sweepTime,c1_sweepTimer);

		c1_volumeTimer = c1_envelopeSweep*4;

		memory->lastAccess = 0;

		memory->writeMemory(0xff26,memory->readMemory(0xff26)|1);
	}

	//channel 2
	/*if (memory->lastAccess == 0xff19 && (memory->readMemory(0xff19)&(1<<7))) {
		c2_enabled = true;
		c2_remaining = 64-(memory->readMemory(0xff16)&(~(3<<6)));
		if (!(memory->readMemory(0xff19)&(1<<6))) c2_remaining = -1;
		c2_freq = 0;
		c2_freq |= memory->readMemory(0xff18);
		c2_freq |= (memory->readMemory(0xff19)&7)<<8;
		c2_freq = 131072/(2048-c2_freq);

		uint8_t duty = DUTY_CYCLES[memory->readMemory(0xff16)&(3<<6)];
		audio->playSquareWave(c2_freq,CHANNEL_SQUARE_2,duty);

		memory->lastAccess = 0;
		memory->writeMemory(0xff26,memory->readMemory(0xff26)|2);
	}*/

	if (lengthTimer--<=0) {
		lengthTimer = 16384;

		if (c1_remaining!=-1) {
			if (--c1_remaining==0) {
				c1_enabled = false;
				c1_remaining = -1;
				memory->writeMemory(0xff26,memory->readMemory(0xff26)&(~1));
				audio->silenceChannel(CHANNEL_SQUARE_1);
				SDL_Log("c1_end\n");
			}
		}

		if (c1_sweepTime != 0 && c1_enabled) {
			if (--c1_sweepTimer==0) {
				c1_sweepTimer = c1_sweepTime*2;
				c1_freq = c1_freq + c1_sweepInc*(c1_freq>>c1_sweepShift);
				audio->playSquareWave(131072/(2048-c1_freq),CHANNEL_SQUARE_1,c1_duty);
				SDL_Log("c1 sweep change %i\n",c1_freq);
			}
		}

		if (c1_enabled && c1_envelopeSweep && --c1_volumeTimer==0) {
			c1_volumeTimer = c1_envelopeSweep*4;
			c1_volume += c1_envelopeInc;
			audio->setChannelVolume(CHANNEL_SQUARE_1,c1_volume);
			if (c1_volume==0) {
				c1_enabled = false;
				c1_remaining = -1;
				memory->writeMemory(0xff26,memory->readMemory(0xff26)&(~1));
			}
		}

		if (c2_remaining!=-1) {
			if (--c2_remaining==0) {
				c2_enabled = false;
				c2_remaining = -1;
				memory->writeMemory(0xff26,memory->readMemory(0xff26)&(~2));
				audio->silenceChannel(CHANNEL_SQUARE_2);
			}
		}
	}
}

} /* namespace audio */
