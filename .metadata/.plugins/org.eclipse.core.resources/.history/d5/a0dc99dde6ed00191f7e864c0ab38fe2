/*
 * i00_1f.h
 *
 *  Created on: 13.10.2019
 *      Author: Tobias
 */

#ifndef I00_1F_H_
#define I00_1F_H_

#include <cstdint>
#include "Processor.h"

namespace proc {

int execute00_1f(uint8_t opcode, Processor * proc) {
	switch (opcode) {
	case 0x00: //nop
		return 1;
	case 0x01: //ld bc,d16
		proc->setBC(proc->getInstruction16());
		return 3;
	case 0x02: //ld (bc),a
		proc->memory->writeMemory(proc->getBC(), proc->a);
		return 2;
	case 0x03: //inc bc
		proc->setBC(proc->getBC()+1);
		return 2;
	case 0x04: //inc b
		proc->b++;
		return 1;
	case 0x05: //dec b
		proc->b--;
		return 1;
	case 0x06: //ld b,d8
		proc->b = proc->getInstruction8();
		return 2;
	case 0x07: //rlca rotate a left
		uint8_t bit7 = (proc->a)>>7;
		proc->setFlag(CARRY_FLAG, bit7);
		proc->a <<= 1;
		proc->a &= ~1;
		proc->a |= bit7;
		return 2;
	case 0x08: //ld (a16), sp
		proc->writeMemory16(proc->getInstruction16(), proc->sp);
		return 5;
	case 0x09: //add hl,bc
		proc->setHL(proc->getBC());
		return 2;
	case 0x0a: //ld a,(bc)
		proc->a = proc->memory->readMemory(proc->getBC());
		return 2;
	case 0x0b: //dec bc
		proc->setBC(proc->getBC()-1);
		return 2;
	case 0x0c: //inc c
		proc->c++;
		return 1;
	case 0x0d: //dec c
		proc->c--;
		return 1;
	case 0x0e: // ld c,d8
		proc->c = proc->memory->readMemory(proc->getInstruction8());
		return 2;
	case 0x0f: //rrca
		uint8_t bit0 = proc->a & 1;
		proc->setFlag(CARRY_FLAG, bit0);
		proc->a >>= 1;
		proc->a &= ~(1<<7);
		proc->a |= bit0;
		return 1;
	case 0x10: // stop 0
		//TODO: add instruction
		proc->getInstruction8();
		return 1;
	}
}

}

#endif /* I00_1F_H_ */
